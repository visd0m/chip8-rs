const FONTS: &[u8] = &[
    0xf0, 0x90, 0x90, 0x90, 0xf0, 0x20, 0x60, 0x20, 0x20, 0x70, 0xf0, 0x10, 0xf0, 0x80, 0xf0, 0xf0,
    0x10, 0xf0, 0x10, 0xf0, 0x90, 0x90, 0xf0, 0x10, 0x10, 0xf0, 0x80, 0xf0, 0x10, 0xf0, 0xf0, 0x80,
    0xf0, 0x90, 0xf0, 0xf0, 0x10, 0x20, 0x40, 0x40, 0xf0, 0x90, 0xf0, 0x90, 0xf0, 0xf0, 0x90, 0xf0,
    0x10, 0xf0, 0xf0, 0x90, 0xf0, 0x90, 0x90, 0xe0, 0x90, 0x90, 0x90, 0xe0, 0xf0, 0x80, 0x80, 0x80,
    0xf0, 0xe0, 0x90, 0x90, 0x90, 0xe0, 0xf0, 0x80, 0xf0, 0x80, 0xf0, 0xf0, 0x80, 0xf0, 0x80, 0x80,
];

#[derive(Debug)]
pub struct Memory([u8; 4096]);

impl Default for Memory {
    fn default() -> Self {
        Memory::new()
    }
}

impl Memory {
    pub fn new() -> Self {
        let mut bytes = [0; 4096];
        initialize_fonts(&mut bytes);
        Self(bytes)
    }

    pub fn read_8(&self, address: u16) -> u8 {
        self.0[address as usize]
    }

    pub fn read_16(&self, address: u16) -> u16 {
        u16::from_be_bytes([self.read_8(address), self.read_8(address + 1)])
    }

    pub fn write_8(&mut self, address: u16, byte: u8) {
        self.0[address as usize] = byte
    }

    pub fn get_font_address(&mut self, font: u8) -> u16 {
        font as u16 * 5_u16
    }

    pub fn load_rom(&mut self, rom: &[u8]) {
        for (index, b) in rom.iter().enumerate() {
            self.write_8((0x200 + index) as u16, *b);
        }
    }
}

fn initialize_fonts(bytes: &mut [u8; 4096]) {
    (0..80)
        .into_iter()
        .for_each(|index| bytes[index] = FONTS[index]);
}
